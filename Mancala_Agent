
	import java.io.BufferedReader;
	import java.io.BufferedWriter;
	import java.io.ByteArrayInputStream;
	import java.io.ByteArrayOutputStream;
	import java.io.File;
	import java.io.FileOutputStream;
	import java.io.FileReader;
	import java.io.FileWriter;
	import java.io.IOException;
	import java.io.ObjectInputStream;
	import java.io.ObjectOutputStream;
	import java.io.PrintStream;
	import java.io.PrintWriter;
	import java.io.Serializable;
	import java.util.ArrayList;
	
	public class mancala implements Serializable {
	  int i;
	public static PrintWriter ot;
	  static Board next;
	  static Board  previousSate;
	  static int plyer;
		
	
		public static void main(String args[]) throws IOException, ClassNotFoundException {
			File inFile = null;
			if (0 < args.length) {
			   inFile = new File(args[1]);
			}
			
		
			@SuppressWarnings("resource")
			BufferedReader br = new BufferedReader(
					//new FileReader("C:\\Users\\vipin\\Documents\\EclipseProject\\mancala\\input.txt"));
					 new FileReader(inFile));
			
				
			int task = Integer.parseInt(br.readLine().trim());
			int player = Integer.parseInt(br.readLine().trim());
			plyer = player;
			int cutoffDepth = Integer.parseInt(br.readLine().trim());
			String[] boardPlayer = br.readLine().split(" ");
			int[] boardPlayer2 = new int[boardPlayer.length];
			for (int i = 0; i < boardPlayer.length; i++) {
				boardPlayer2[i] = Integer.parseInt(boardPlayer[i]);
			}
			boardPlayer = br.readLine().split(" ");
			int[] boardPlayer1 = new int[boardPlayer.length];
			for (int i = 0; i < boardPlayer.length; i++) {
				boardPlayer1[i] = Integer.parseInt(boardPlayer[i]);
			}
			int mancalaPlayer2 = Integer.parseInt(br.readLine().trim());
			int mancalaPlayer1 = Integer.parseInt(br.readLine().trim());
			int boardSize = (boardPlayer2.length) * 2 + 2;
			Board board = new Board(task,player, cutoffDepth, boardSize, boardPlayer2, boardPlayer1, mancalaPlayer2,
					mancalaPlayer1);
			 next = new Board(task,player, cutoffDepth, boardSize, boardPlayer2, boardPlayer1, mancalaPlayer2,
					mancalaPlayer1);
			 previousSate =new Board(task,player, cutoffDepth, boardSize, boardPlayer2, boardPlayer1, mancalaPlayer2,
						mancalaPlayer1);
			next.utility =Double.NEGATIVE_INFINITY;
			if (task == 1) {
				
				Board bt = (board.MaxUtility()).copy();
				 bt.GreedyPrint(bt);
			} else if (task == 2) {
				 ot = new PrintWriter(new FileWriter("traverse_log.txt",false));
	
						 //new PrintWriter(new FileWriter("C:\\Users\\vipin\\Documents\\EclipseProject\\mancala\\traverse_log.txt",false));
							ot.close();
		 ot = new PrintWriter(new FileWriter("traverse_log.txt",true));
				 //new PrintWriter(new FileWriter("C:\\Users\\vipin\\Documents\\EclipseProject\\mancala\\traverse_log.txt",true));
				
		 board.Printroot("Node,Depth,Value",ot);
				
				if(player ==1){
					board.Printroot("root,0,-Infinity",ot);
					board.minimax(player,false,1,false,"max",next,ot);
				ot.close();
				board.nextState(player,false,1,false,"max",next,ot);
			}
			else if(player == 2){
				
				board.Printroot("root,0,-Infinity",ot);
				board.minimax(player,false,1,false,"max",next,ot);
				ot.close();
				board.nextState(player,false,1,false,"max",next,ot);
					
			
			}
			}
			else if(task  ==3){
				 ot = new PrintWriter(new FileWriter("traverse_log.txt",false));
	
				// new PrintWriter(new FileWriter("C:\\Users\\vipin\\Documents\\EclipseProject\\mancala\\traverse_log.txt",false));
					ot.close();
				 ot = new PrintWriter(new FileWriter("traverse_log.txt",true));
						// new PrintWriter(new FileWriter("C:\\Users\\vipin\\Documents\\EclipseProject\\mancala\\traverse_log.txt",false));

				 board.Printroot("Node,Depth,Value,Alpha,Beta",ot);
					
				if(player ==1){
					board.Printroot("root,0,-Infinity,-Infinity,Infinity",ot);
					double alpha = Double.NEGATIVE_INFINITY;
					double beta = Double.POSITIVE_INFINITY;
					board.Alphaminimax(player,false,1,false,"max",next,alpha,beta,ot);
					ot.close();
					board.nextState(player,false,1,false,"max",next,ot);
				
			}
			else if(player == 2){
				board.Printroot("root,0,-Infinity,-Infinity,Infinity",ot);
				double alpha = Double.NEGATIVE_INFINITY;
				double beta = Double.POSITIVE_INFINITY;
				board.Alphaminimax(player,false,1,false,"max",next,alpha,beta,ot);
				ot.close();
				board.nextState(player,false,1,false,"max",next,ot);
					
			
			}
			}
		}
	}
	
	class Board  implements Serializable  {
	
		int Player;
		int cutOffDepth;
		int[] boardPlayer1;
		int[] boardPlayer2;
		int mancalaPlayer2;
		int mancalaPlayer1;
		int boardSize;
		double utility;
		int currentDepth;
		int LastMove;
		int currentIndex;
		String callFunction;
		double alpha;
		double beta;
		int opponent;
		
		static double  max_eval  =Double.NEGATIVE_INFINITY;
		 static mancala minObj = new mancala();
		static Board nextState =null;
		int task;
	
		public ArrayList<Board> maxBoards = new ArrayList<Board>(1000);
		public pits[] pits;
		private boolean sameLayer;
		
		public Board(int task,int Player, int cutoffDepth, int boardSize, int[] boardPlayer2, int[] boardPlayer1, int mancalaPlayer2,
				int mancalaPlayer1) {
			this.Player = Player;
			
			this.task = task;
			this.alpha = alpha;
			this.beta = beta;
			
			this.cutOffDepth = cutoffDepth;
			this.boardSize = boardSize;
			this.boardPlayer2 = boardPlayer2;
			this.boardPlayer1 = boardPlayer1;
			this.mancalaPlayer2 = mancalaPlayer2;
			this.mancalaPlayer1 = mancalaPlayer1;
			
			
			
			pits[] pits = new pits[boardSize];
			for (int i = 0; i < boardSize; i++) {
				pits[i] = new pits();
			}
			int pitNumber = MancalaCurrentPlayer(1, boardSize);
			pits[pitNumber].setStones(mancalaPlayer1);
			pitNumber = MancalaCurrentPlayer(2, boardSize);
			pits[pitNumber].setStones(mancalaPlayer2);
			if (Player == 1) {
				for (int j = 1; j <= boardPlayer1.length; j++) {
					pits[j].setStones((boardPlayer1[j - 1]));
	
				}
	
				for (int i = 0; i < boardPlayer2.length / 2; i++) {
					int temp = boardPlayer2[i];
					boardPlayer2[i] = boardPlayer2[boardPlayer2.length - i - 1];
					boardPlayer2[boardPlayer2.length - i - 1] = temp;
				}
				for (int k = boardPlayer2.length + 2; k < boardSize; k++) {
					pits[k].setStones((boardPlayer2[k - (boardPlayer2.length + 2)]));
	
				}
	
			}
			if (Player == 2) {
	
				for (int k = 1; k <= boardPlayer2.length; k++) {
					pits[k].setStones((boardPlayer2[k - 1]));
	
				}
				for (int i = 0; i < boardPlayer1.length / 2; i++) {
					int temp = boardPlayer1[i];
					boardPlayer1[i] = boardPlayer1[boardPlayer1.length - i - 1];
					boardPlayer1[boardPlayer1.length - i - 1] = temp;
				}
				for (int k = boardPlayer1.length + 2; k < boardSize; k++) {
					pits[k].setStones((boardPlayer1[k - (boardPlayer1.length + 2)]));
	
				}
	
			}
			this.pits = pits;
		}
	
		public Board() {
			super();
		}
	
		public Board copy() throws IOException, ClassNotFoundException {
			
				
			/*	  ByteArrayOutputStream bs = new ByteArrayOutputStream();
				  ObjectOutputStream o = new ObjectOutputStream(bs); o.writeObject(this);
				  o.flush(); o.close(); bs.close(); byte[] byteData = bs.toByteArray();
				  ByteArrayInputStream ba = new ByteArrayInputStream(byteData);
				  Board temp = (Board) new
				  ObjectInputStream(ba).readObject();
				return temp */
				 
				Board newBoard = new Board();
				double[] temp = new double[boardSize];
				  pits[] ptemp = new pits[boardSize] ;
				  for  (int  j  =  0;  j  < pits.length;  j++){
			        ptemp[j] = new pits();
	
			        	
				}
				for  (int  j  =  0;  j  < pits.length;  j++){
			        	double temp1 =this.pits[j].getStones();
	
			        	ptemp[j].setStones(temp1);
				}
				                        
				  newBoard.pits = ptemp;
				    
				
			
			
				
				int Player = this.Player;
				newBoard.Player = Player;
				int cutoffDepth = this.cutOffDepth;
				newBoard.cutOffDepth = cutoffDepth;
				int[] boardPlayer1 =this.boardPlayer1;
				newBoard.boardPlayer1 = boardPlayer1;
				int[] boardPlayer2 =this.boardPlayer2;
				newBoard.boardPlayer2 = boardPlayer2;
				
				int mancalaPlayer2 = this.mancalaPlayer2; 
				newBoard.mancalaPlayer2 = mancalaPlayer2;
				int mancalaPlayer1 = this.mancalaPlayer1; 
				newBoard.mancalaPlayer1 = mancalaPlayer1;
				  int bsize = this.boardSize;
				newBoard.boardSize =bsize;
				double utility =this.utility;
				newBoard.utility = utility;
				int currentDepth =this.currentDepth;
				newBoard.currentDepth = currentDepth;
				String callFunction =this.callFunction;
				newBoard.currentIndex = this.currentIndex;
			newBoard.callFunction = callFunction;
			double alpha = this.alpha;
			newBoard.alpha = alpha;
			double beta = this.beta;
			newBoard.beta   =beta;
			double  max_eval  =this.max_eval;
			newBoard.max_eval =max_eval;
			 Board nextstate = this.nextState;
			 newBoard.nextState =nextstate;
			int task  =this.task;
			newBoard.task = task;
			boolean sameLayer = this.sameLayer;
			newBoard.sameLayer = sameLayer;
			
				return newBoard;
			}
		
	
		
		 public  Board  makeACopy()  {
		        Board  newBoard  =  new Board(task,Player, cutOffDepth, boardSize, boardPlayer2, boardPlayer1, mancalaPlayer2,
						mancalaPlayer1);
		        for  (int  pitNum  =  0;  pitNum  < pits.length;  
		              pitNum++){
		        	double temp =this.pits[pitNum].getStones();
		           newBoard.pits[pitNum].setStones(temp);}
		        return  newBoard;
		    }
	
		public Board MaxUtility() throws ClassNotFoundException, IOException {
	
			// Board clonedBoard =copy(bd);
			for (int i = 1; i <= boardPlayer1.length; i++) {
				moveUtility(i);
	
			}
	
			return maxboardvlaue();
	
		}
	
		public Board maxboardvlaue() {
				
			if(this.task == 1){
					Board maxboard = null;
		
			double maxvalue = -100000;
			for (Board i : maxBoards) {
				double value = Eval(i,Player);
	
				if (value > maxvalue) {
					if (this.mancalaPlayer1 == this.pits[MancalaCurrentPlayer(1, boardSize)].getStones()
							&& this.mancalaPlayer2 == this.pits[MancalaCurrentPlayer(2, boardSize)].getStones()) {
						maxboard = maxboard;
					}
					maxvalue = value;
					maxboard = i;
	
				}
	
			}
			return maxboard;
		}
		
		if(task == 2){
			Board maxboard = null;
			
			double maxvalue = -100000;
			for (Board i : maxBoards) {
				double value = i.utility;
	
				if (value > maxvalue) {
					maxvalue = value;
					maxboard = i;
	
				}
	
			}
			return maxboard;
		}
		return null;
			
		}
	
		public double Eval(Board bd, int Player) {
			if (Player == 1) {
				double val1 = bd.pits[MancalaCurrentPlayer(1, boardSize)].getStones();
				double val2 = bd.pits[MancalaCurrentPlayer(2, boardSize)].getStones();
				return val1 - val2;
			}
			if (Player == 2) {
				double val1 = bd.pits[MancalaCurrentPlayer(1, boardSize)].getStones();
				double val2 = bd.pits[MancalaCurrentPlayer(2, boardSize)].getStones();
				return val2 - val1;
			}
			return 0;
		}
	
		public Board moveUtility(int pitNumber) throws ClassNotFoundException, IOException {
			if (Player == 1) {
	
				Board clboard = makeACopy();
				if (pitStones(clboard, pitNumber) == 0) {
				
					return clboard;
	
				} else if (!isMancalaPlayer1(clboard, pitNumber)) {
					clboard.movePlayer1(pitNumber);
					
	
					maxBoards.add(clboard);
				} else if (isMancalaPlayer1(clboard, pitNumber)) {
					Board bs;
					clboard.movePlayer1(pitNumber);
					if(!(isGameOverPlayer1(clboard))|| !(isGameOverPlayer2(clboard))){
						 bs = clboard.MaxUtility();
						}
						else{
						 bs = clboard;
						}
					maxBoards.add(bs);
	
				}
	
				return clboard;
	
			} else if (Player == 2) {
	
				Board clboard = makeACopy();
				if (pitStones(clboard, pitNumber) == 0) {
					return clboard;
				} else if (!isMancalaPlayer2(clboard, pitNumber)) {
					clboard.movePlayer2(pitNumber);
					maxBoards.add(clboard);
				} else if (isMancalaPlayer2(clboard, pitNumber)) {
					Board bs;
					clboard.movePlayer2(pitNumber);
					if(!(isGameOverPlayer1(clboard))|| !(isGameOverPlayer2(clboard))){
					 bs = clboard.MaxUtility();
					}
					else{
					 bs = clboard;
					}
					maxBoards.add(bs);
				}
	
				return clboard;
	
			}
			return null;
		}
	
		public double pitStones(Board bd, int pitNumber) {
			return (bd.pits[pitNumber].getStones());
		}
	
		public boolean isMancalaPlayer1(Board bd, int pitNumber) {
			int temp;
			if (pits[pitNumber].getStones() <= bd.MancalaCurrentPlayer(1, boardSize))
				return (bd.pits[pitNumber].getStones() + pitNumber) == bd.MancalaCurrentPlayer(1, boardSize);
			else {
			temp = (int)pits[pitNumber].getStones() %(boardSize-1);
			return (temp + pitNumber) == bd.MancalaCurrentPlayer(1, boardSize);
	
			}
		}
	
		public boolean isMancalaPlayer2(Board bd, int pitNumber) {
			double temp =bd.pits[pitNumber].getStones()%(boardSize-1);
			return (pitNumber - temp ) == bd.MancalaCurrentPlayer(2, boardSize);
	
		}
	
		public boolean isGameOverPlayer1(Board bd) {
			boolean result = true;
	
			for (int i = 1; i <= boardPlayer1.length; i++) {
				if (bd.pits[i].getStones() != 0)
					result = false;
			}
			return result;
		}
	
		public boolean isGameOverPlayer2(Board board) {
			boolean result = true;
	
			for (int i = boardPlayer2.length + 2; i < boardSize; i++) {
				if (board.pits[i].getStones() != 0)
					result = false;
			}
			return result;
		}
	
		public void movePlayer1(int pitNumber) throws ClassNotFoundException, IOException {
	
			int pitbackup = pitNumber;
			double stones = pits[pitNumber].getStones();
	
			pits[pitbackup].setStones(0);
	
			while (stones != 0) {
				if (stones == 1) {
					if ((isValidPit(pitNumber)||(pitNumber == (MancalaCurrentPlayer(2,pits.length))))) {
						if (pits[pitNumber + 1].getStones() == 0
								&& (pitNumber + 1) != ((MancalaCurrentPlayer(1, pits.length)))) {
							int temp = (pits.length - pitNumber - 1);
							pits[MancalaCurrentPlayer(1, pits.length)].setStones(
									pits[MancalaCurrentPlayer(1, pits.length)].getStones() + (pits[temp].getStones() + 1));
							stones--;
							pits[temp].setStones(0);
							break;
						}
					}
				}
				pitNumber++;
				if (pitNumber > boardSize - 1) {
					pitNumber = 0;
				}
	
				if (pitNumber != (MancalaCurrentPlayer(2, pits.length))) {
					pits[pitNumber].setStones(pits[pitNumber].getStones() + 1);
					stones--;
	
				}
	
			}
			if (isGameOverPlayer1(this)) { // Below level is all zero where we have
											// player 1 then put into palyer 2
											// mancala
	
				for (int k = boardPlayer2.length + 2; k < boardSize; k++) {
					pits[MancalaCurrentPlayer(2, boardSize)]
							.setStones(pits[k].getStones() + pits[MancalaCurrentPlayer(2, boardSize)].getStones());
					pits[k].setStones(0);
				}
			} else if (isGameOverPlayer2(this)) {
				for (int k = 1; k <=boardPlayer1.length; k++) {
					pits[MancalaCurrentPlayer(1, boardSize)]
							.setStones(pits[k].getStones() + pits[MancalaCurrentPlayer(1, boardSize)].getStones());
					pits[k].setStones(0);
				}
			}
		}
	
		public void movePlayer2(int pitNumber) throws ClassNotFoundException, IOException {
	
			int pitbackup = pitNumber;
			double stones = pits[pitNumber].getStones();
	
			pits[pitbackup].setStones(0);
	
			while (stones != 0) {
				if (stones == 1) {
						//(pitNumber == MancalaCurrentPlayer(1,pits.length)(Removed from below if condition
					if (isValidPit(pitNumber)||(pitNumber == (MancalaCurrentPlayer(1,pits.length))) ) {
						if (pits[pitNumber - 1].getStones() == 0
								&& (pitNumber - 1) != ((MancalaCurrentPlayer(2, pits.length)))) {
							int temp = pits.length - pitNumber + 1;
							pits[MancalaCurrentPlayer(2, pits.length)].setStones(
									pits[MancalaCurrentPlayer(2, pits.length)].getStones() + (pits[temp].getStones() + 1));
							stones--;
							pits[temp].setStones(0);
							break;
						}
					}
				}
				pitNumber--;
				if (pitNumber < 0) {
					pitNumber = boardSize - 1;
				}
	
				if (pitNumber != (MancalaCurrentPlayer(1, pits.length))) {
					pits[pitNumber].setStones(pits[pitNumber].getStones() + 1);
					stones--;
	
				}
			/*	if (pits[1].getStones() == 0 && pits[2].getStones() == 1 && pits[3].getStones() == 0
						&& pits[0].getStones() == 5) {
					
	
				}*/
	
			}
			if (isGameOverPlayer1(this)) {// In array reperesntation first we have
											// player 2
				for (int k = boardPlayer2.length + 2; k <boardSize; k++) {
					pits[MancalaCurrentPlayer(1, boardSize)]
							.setStones(pits[k].getStones() + pits[MancalaCurrentPlayer(1, boardSize)].getStones());
					pits[k].setStones(0);
	
				}
			} else if (isGameOverPlayer2(this)) {
				for (int k = 1; k <=boardPlayer1.length; k++) {
					pits[MancalaCurrentPlayer(2, boardSize)]
							.setStones(pits[k].getStones() + pits[MancalaCurrentPlayer(2, boardSize)].getStones());
					pits[k].setStones(0);
				}
			}
	
		}
	
		public boolean isValidPit(int pitNumber) {
			boolean result = false;
			for (int i = 1; i <= boardPlayer1.length; i++) {
				if (pitNumber == i) {
					result = true;
					return result;
				} else {
					result = false;
					
				}
	
			}
			return result;
		}
	
		public int MancalaCurrentPlayer(int Player, int BoardSize) {
			int pitNum;
			if (Player == 1) {
				pitNum = (BoardSize / 2);
				return pitNum;
			} else if (Player == 2) {
				pitNum = 0;
				return pitNum;
			}
			return 0;
	
		}
		public void minimax(int Player,boolean freemove,int pitNumber,boolean sameLayer,String callFunction, Board next,PrintWriter ot) throws ClassNotFoundException, IOException{
			
			this.max(Player,freemove,pitNumber,sameLayer,"max",next,ot);
			max_eval= Double.NEGATIVE_INFINITY;
			this.maxnextsate(Player,freemove,pitNumber,sameLayer,"max",next);
			
			Print(minObj.next);
		
		}
		public void Alphaminimax(int Player,boolean freemove,int pitNumber,boolean sameLayer,String callFunction,Board next,double alpha,double beta,PrintWriter ot) throws ClassNotFoundException, IOException{
			this.alpha =Double.NEGATIVE_INFINITY;
			this.beta = Double.POSITIVE_INFINITY;
			this.alphaMax(Player,freemove,pitNumber,sameLayer,"max",next,alpha,beta,ot);
			max_eval= Double.NEGATIVE_INFINITY;
		//	if(minObj.next.pits == this.pits)
			
				 
			
		}
		public void nextState(int Player,boolean freemove,int pitNumber,boolean sameLayer,String callFunction,Board next,PrintWriter ot) throws ClassNotFoundException, IOException{
			max_eval= Double.NEGATIVE_INFINITY;
			this.maxnextsate(Player,freemove,pitNumber,sameLayer,"max",next);

				 Print(minObj.next);
			
		}
		
		/*public Board nextState(Board bd, int pitNumber ) throws ClassNotFoundException, IOException{
		   Board nextState = new Board(task,Player, cutOffDepth, boardSize, boardPlayer2, boardPlayer1, mancalaPlayer2,
					mancalaPlayer1);
			if(bd.currentDepth ==1 && ! isMancalaPlayer1(bd,pitNumber)){
				if(bd.utility >nextState.utility ){
					nextState =bd.copy();
				}
				
	}
			return nextState;
		}*/
	
		public Board alphaMax(int Player,boolean freemove,int pitNumber,boolean sameLayer,String callFunction,Board next, double alpha, double beta,PrintWriter ot) throws ClassNotFoundException, IOException {
			
			Board temp = copy();
			temp.utility = Double.NEGATIVE_INFINITY;
		    Board returnCopy = null;
			temp.currentIndex =pitNumber;
	
			if (Player == 1) {
			int opponent = 2;
			
			 
			if (IsTerminal(freemove)) {
				this.utility = (int) Eval(this,Player);
				 PrintAlphaBetaLog(this,pitNumber,opponent,alpha,beta,ot);
				return this;
	
			}
			boolean terminalFreemove = false;
				for (int i = 1; i <=boardPlayer1.length; i++) {
	
					Board clboard = temp.copy();
					Board backstate = clboard.copy();
					double maxUtility = Double.NEGATIVE_INFINITY;
					double minUtility = Double.POSITIVE_INFINITY;
					if (isMancalaPlayer1(clboard, i)) {
						Board back = clboard.copy();
						clboard.movePlayer1(i);
						if(!sameLayer){
							clboard.currentDepth++;
							
							}
						
						if(isGameOverPlayer1(clboard) || isGameOverPlayer2(clboard)){
							clboard.utility = maxUtility;
							PrintAlphaBetaLog(clboard,i,Player,alpha,beta,ot);    //Need to check code so if you need to print the inf value at leaf node or not
							clboard.utility = maxUtility;
						//	PrintAlphaBetaLog(clboard,i,Player,alpha,beta,ot);
							clboard.utility = (int) Eval(clboard,Player);
							PrintAlphaBetaLog(clboard,i,Player,alpha,beta,ot);
					if(temp.utility <= clboard.utility){
				    	 temp.utility =clboard.utility;
				     }
				 	 
					 	else{
					    	 temp.utility = temp.utility;
					     }
					 if(isGameOverPlayer1(clboard) || isGameOverPlayer2(clboard)){
						 
			    		 clboard.Printroot("root"+","+"0"+","+(int)temp.utility,alpha,beta,ot);
					 }
			    		 else {
					if(callFunction =="max")
					PrintAlphaBetaLog(temp,temp.currentIndex,Player,alpha,beta,ot);
					else
						PrintAlphaBetaLog(temp,temp.currentIndex,opponent,alpha,beta,ot);
			    		 }
						returnCopy = temp.copy();
						
							
					
						return returnCopy;
						}
							else
								clboard.utility = maxUtility;
						
					PrintAlphaBetaLog(clboard,i,Player,alpha,beta,ot);
					
						
						Board bts=  clboard.alphaMax(Player,true,i,true,"max",next,alpha,beta,ot);
						if(temp.utility <= bts.utility){
					    	 temp.utility =bts.utility;
					     }
					 	else{
					    	 temp.utility = temp.utility;
					     }
						
						if(bts.utility >= temp.beta){
							
							if(callFunction =="max")
					    		 PrintAlphaBetaLog(temp,temp.currentIndex,Player,alpha,beta,ot);
							  		else
							    		 PrintAlphaBetaLog(temp,temp.currentIndex,opponent,alpha,beta,ot);
					    		 
							  	return temp;
							 
						}
						alpha = Math.max(alpha, bts.utility);
						temp.alpha = alpha;
						if(!sameLayer){
					    	 if(temp.currentDepth == 0){
					    	//	 nextState.maxBoards.add(bt);
					    		 clboard.Printroot("root"+","+"0"+","+(int)temp.utility,temp.alpha,temp.beta,ot);
					    	 returnCopy = temp.copy();
							 continue;
					    	 }
					    	 else
					    		 PrintAlphaBetaLog(temp,temp.currentIndex,opponent,alpha,beta,ot);
					     }
					     else{
					    	 if(temp.currentDepth == 0){
					    	//	 nextState.maxBoards.add(bt);
					    		 clboard.Printroot("root"+","+"0"+","+(int)temp.utility,temp.alpha,temp.beta,ot);
						    	 returnCopy = temp.copy();
								 continue;}
					    	 else
					    	 
					    		 PrintAlphaBetaLog(temp,temp.currentIndex,Player,alpha,beta,ot);
					     
					     }
					returnCopy = temp;
					}
					else {
					if (clboard.pits[i].getStones() == 0) {
						 returnCopy = temp.copy();
						 continue;
					}
					clboard.utility = minUtility;
					clboard.movePlayer1(i);
				//	PrintPits(clb,oard);
					if(!sameLayer){
						clboard.currentDepth++;
						}
			
					///PrintLog(clboard,i,opponent);
					if(clboard.currentDepth == cutOffDepth  ){
					if (isMancalaPlayer1(clboard, i))
						PrintAlphaBetaLog(clboard,i,Player,alpha,beta,ot);
					}
					else{
						PrintAlphaBetaLog(clboard,i,Player,alpha,beta,ot);
					}
					
					//Board backup = clboard.copy();
					
				    	Board Backup = clboard.copy();
		    	 
					Board bt =clboard.BoardPlayer2().Alphamin(opponent,false,i,false,"max",next,alpha,beta,ot);
					//PrintPits(clboard);
					  if(temp.utility <= bt.utility){
					    	 temp.utility =bt.utility;
					     }
					  
					  else {
						  temp.utility = temp.utility;
					  }
					  
						  if(bt.utility >= temp.beta){
							 
						    			 if((callFunction =="max"))
						    		 
					    		 PrintAlphaBetaLog(temp,temp.currentIndex,Player,alpha,beta,ot);
							  		else
							    		 PrintAlphaBetaLog(temp,temp.currentIndex,opponent,alpha,beta,ot);
						    		 
							  	return temp;
							}
							alpha = Math.max(alpha, bt.utility);
							temp.alpha = alpha;
						
					
					     if(!sameLayer){
					    	 if(temp.currentDepth == 0){
					    	//	 nextState.maxBoards.add(bt);
					    		 clboard.Printroot("root"+","+"0"+","+(int)temp.utility,temp.alpha,temp.beta,ot);
					    	 returnCopy = temp.copy();
							 continue;}
					    	 else
					    		 PrintAlphaBetaLog(temp,temp.currentIndex,opponent,alpha,beta,ot);
					     }
					     else{
					    	 if(temp.currentDepth == 0){
					    		// nextState.maxBoards.add(bt);
					    		 clboard.Printroot("root"+","+"0"+","+(int)temp.utility,temp.alpha,temp.beta,ot);
					    		 returnCopy = temp.copy();
								 continue;}
					    	 else{
					    	 
					    		 PrintAlphaBetaLog(temp,temp.currentIndex,Player,alpha,beta,ot);
					    	 }
					     
					    	
					     }
					
					     returnCopy = temp.copy();
					 	if( !isMancalaPlayer1(backstate,i)){
							if(temp.currentDepth ==0){
								if(bt.utility > max_eval ){
						    		 max_eval=bt.utility;
						    		 minObj.next =clboard.copy() ;
						    		
						    	 }
							}
							else {
								if(temp.currentDepth ==1){
									if(bt.utility > max_eval ){
							    		 max_eval=bt.utility;
							    		 minObj.next =clboard.copy() ;
							    		
							    	 }
								
							}
						 }
						}
					
					}
					    
					  
					  
					    
				}
				
			}
			if(Player == 2){
				int opponent = 1;
				
				 
				if (IsTerminal(freemove)) {
					this.utility = (int) Eval(this,Player);
					 PrintAlphaBetaLog(this,pitNumber,opponent,alpha,beta,ot);
					return this;
	
				}
				boolean terminalFreemove = false;
					for (int i = 1; i <=boardPlayer1.length; i++) {
						
						Board clboard = temp.copy();
						Board backstate = clboard.copy();
						double maxUtility = Double.NEGATIVE_INFINITY;
						double minUtility = Double.POSITIVE_INFINITY;
						if (isMancalaPlayer2(clboard, i)) {
							clboard.movePlayer2(i);
							if(!sameLayer){
								clboard.currentDepth++;
								
								}
							
							if(isGameOverPlayer1(clboard) || isGameOverPlayer2(clboard)){
								clboard.utility = maxUtility;
								PrintAlphaBetaLog(clboard,i,Player,alpha,beta,ot);    //Need to check code so if you need to print the inf value at leaf node or not
								clboard.utility = maxUtility;
								PrintAlphaBetaLog(clboard,i,Player,alpha,beta,ot);
								clboard.utility = (int) Eval(clboard,Player);
								PrintAlphaBetaLog(clboard,i,Player,alpha,beta,ot);
						if(temp.utility <= clboard.utility){
					    	 temp.utility =clboard.utility;
					     }
					 	 
						 	else{
						    	 temp.utility = temp.utility;
						     }
						if(isGameOverPlayer1(clboard) || isGameOverPlayer2(clboard)){
				    		 clboard.Printroot("root"+","+"0"+","+(int)temp.utility,alpha,beta,ot);
						 }
				    		 else {
						if(callFunction =="max")
							PrintAlphaBetaLog(temp,temp.currentIndex,Player,alpha,beta,ot);
						else
							PrintAlphaBetaLog(temp,temp.currentIndex,opponent,alpha,beta,ot);}
							returnCopy = temp.copy();
							 if(clboard.currentDepth ==1 && !isMancalaPlayer2(clboard,i)){
						    	 if(nextState == null){
						    		 nextState =clboard;
						    	 }
									if(returnCopy.utility >nextState.utility ){
										nextState =clboard.copy();
									}
									
						}
							return returnCopy;
							}
								else
									clboard.utility = maxUtility;
							
							PrintAlphaBetaLog(clboard,i,Player,alpha,beta,ot);
						
							
							Board bt=  clboard.alphaMax(Player,true,i,true,"max",next,alpha,beta,ot);
							if(temp.utility <= bt.utility){
						    	 temp.utility =bt.utility;
						     }
						 	else{
						    	 temp.utility = temp.utility;
						     }
							if(bt.utility >= temp.beta){
							
					    		 PrintAlphaBetaLog(temp,temp.currentIndex,opponent,alpha,beta,ot);
					    		 return temp;
								 
							}
							alpha = Math.max(alpha, bt.utility);
							temp.alpha = alpha;
							if(!sameLayer){
						    	 if(temp.currentDepth == 0){
						    		// nextState.maxBoards.add(bt);
						    		 clboard.Printroot("root"+","+"0"+","+(int)temp.utility,temp.alpha,temp.beta,ot);}
						    	 else
						    		 PrintAlphaBetaLog(temp,temp.currentIndex,opponent,alpha,beta,ot);
						     }
						     else{
						    	 if(temp.currentDepth == 0){
						    		// nextState.maxBoards.add(bt);
						    		 clboard.Printroot("root"+","+"0"+","+(int)temp.utility,temp.alpha,temp.beta,ot);}
						    	 else
						    	 
						    		 PrintAlphaBetaLog(temp,temp.currentIndex,Player,alpha,beta,ot);
						     
						     }
					returnCopy = temp;	}
						else {
						if (clboard.pits[i].getStones() == 0) {
							 returnCopy = temp.copy();
							 continue;
						}
						clboard.utility = minUtility;
						clboard.movePlayer2(i);
					//	PrintPits(clb,oard);
						if(!sameLayer){
							clboard.currentDepth++;
							}
				
						///PrintLog(clboard,i,opponent);
						if(clboard.currentDepth == cutOffDepth  ){
						if (isMancalaPlayer1(clboard, i))
							PrintAlphaBetaLog(clboard,i,Player,alpha,beta,ot);
						}
						else{
							PrintAlphaBetaLog(clboard,i,Player,alpha,beta,ot);
						}
						
						Board backup = clboard.copy();
						Board bt =clboard.BoardPlayer1().Alphamin(opponent,false,i,false,"max",next,alpha,beta,ot);
						//PrintPits(clboard);
						  if(temp.utility <= bt.utility){
						    	 temp.utility =bt.utility;
						     }
						  else {
							  temp.utility = temp.utility;
						  }
						  if(bt.utility >= temp.beta){
							if(callFunction =="max")									
						    		 PrintAlphaBetaLog(temp,temp.currentIndex,Player,alpha,beta,ot);							    		 
								  		else		
								    		 PrintAlphaBetaLog(temp,temp.currentIndex,opponent,alpha,beta,ot);
					    	
								 return temp;
							}
						
						alpha = Math.max(alpha, bt.utility);
						temp.alpha = alpha;
					
						     if(!sameLayer){
						    	 if(temp.currentDepth == 0){
						    		// nextState.maxBoards.add(bt);
						    		 clboard.Printroot("root"+","+"0"+","+(int)temp.utility,temp.alpha,temp.beta,ot);}
						    	 else
						    		 PrintAlphaBetaLog(temp,temp.currentIndex,opponent,alpha,beta,ot);
						     }
						     else{
						    	 if(temp.currentDepth == 0){
						    		// nextState.maxBoards.add(bt);
						    	 
						    		 clboard.Printroot("root"+","+"0"+","+(int)temp.utility,temp.alpha,temp.beta,ot);}
						    	 else
						    		 PrintAlphaBetaLog(temp,temp.currentIndex,Player,alpha,beta,ot);
						     
						     }
						
						     
						     if(backup.currentDepth ==1 && !isMancalaPlayer2(backup,i)){
						    	 if(nextState == null){
						    		 nextState =backup;
						    	 }
									if(backup.utility >nextState.utility ){
										nextState =backup.copy();
									}
									
						}
						     
			returnCopy = temp;
			if( !isMancalaPlayer1(backstate,i)){
				if(temp.currentDepth ==0){
					if(bt.utility > max_eval ){
			    		 max_eval=bt.utility;
			    		 minObj.next =clboard.copy() ;
			    		
			    	 }
				}
				else {
					if(temp.currentDepth ==1){
						if(bt.utility > max_eval ){
				    		 max_eval=bt.utility;
				    		 minObj.next =clboard.copy() ;
				    		
				    	 }
					
				}
			 }
			}
					
						}
			
	}
			}	 
			return returnCopy;
			
	
		}
	
		
	
		
		public Board Alphamin(int Player,boolean freemove,int pitNumber,boolean sameLayer,String callFunction,Board next, double alpha, double beta,PrintWriter ot) throws ClassNotFoundException, IOException {
			Board temp1 = copy();
			temp1.utility = Double.POSITIVE_INFINITY;
			 Board returnCopy = null;
			temp1.currentIndex =pitNumber;
			
			if (Player == 2) {
				int opponent = 1;
				if (IsTerminal(freemove)) {
					this.utility = (int) Eval(this,opponent);
				
					PrintAlphaBetaLog(this,pitNumber,opponent,alpha,beta,ot);
					return this;
					}
	
				
				boolean terminalFreemove = false;
				for (int i = 1; i <=boardPlayer1.length; i++) {
					int indexBackup = i;
					
					Board clboard1 = temp1.copy();
					double minUtility = Double.POSITIVE_INFINITY;
					double maxUtility = Double.NEGATIVE_INFINITY;
					if (isMancalaPlayer2(clboard1, i)) {
						clboard1.movePlayer2(i);
						//PrintPits(clboard1);
						if(!sameLayer){
							clboard1.currentDepth++;
							}
						if(isGameOverPlayer1(clboard1) || isGameOverPlayer2(clboard1)){
							clboard1.utility = minUtility;
							PrintAlphaBetaLog(clboard1,i,Player,alpha,beta,ot);
							clboard1.utility = (int) Eval(clboard1,opponent);
							PrintAlphaBetaLog(clboard1,i,Player,alpha,beta,ot);
					if(temp1.utility >= clboard1.utility){
				    	 temp1.utility =clboard1.utility;
				     }
				 	 
				 	else{
				    	 temp1.utility = temp1.utility;
				     }
					if(isGameOverPlayer1(clboard1) || isGameOverPlayer2(clboard1)){
			    		 clboard1.Printroot("root"+","+"0"+","+(int)temp1.utility,alpha,beta,ot);
					 }
			    		 else {
					if(callFunction =="min")
						PrintAlphaBetaLog(temp1,temp1.currentIndex,Player,alpha,beta,ot);
						else
							PrintAlphaBetaLog(temp1,temp1.currentIndex,opponent,alpha,beta,ot);}
					returnCopy = temp1.copy();
					return returnCopy;
					}
						else
							clboard1.utility = minUtility;
						
						PrintAlphaBetaLog(clboard1,i,Player,alpha,beta,ot);
					 	Board bt = clboard1.Alphamin(Player,true,i,true,"min",next,alpha,beta,ot);
					// 	PrintPits(clboard1);
					 	 if(temp1.utility >= bt.utility){
					    	 temp1.utility =bt.utility;
					     }
					 	 
					 	else{
					    	 temp1.utility = temp1.utility;
					     }
					 	 if(bt.utility <= temp1.alpha){
					 	
					 		 if((callFunction =="min"))
					    		 PrintAlphaBetaLog(temp1,temp1.currentIndex,Player,alpha,beta,ot);
							  else
						    		 PrintAlphaBetaLog(temp1,temp1.currentIndex,opponent,alpha,beta,ot);
							 return temp1;
							}	
						
							
							
							beta = Math.min(temp1.beta, bt.utility);
							temp1.beta = beta;
						beta = Math.min(beta,bt.utility);
						temp1.beta = beta;
					 	if(!sameLayer){
					 		
					    	 if(temp1.currentDepth == 0)
					    		 clboard1.Printroot("root"+","+"0"+","+(int)temp1.utility,temp1.alpha,temp1.beta,ot);
					    	 else
					    		 PrintAlphaBetaLog(temp1,temp1.currentIndex,opponent,alpha,beta,ot);
					     }
					     else{
					    	 if(temp1.currentDepth == 0)
					    		 clboard1.Printroot("root"+","+"0"+","+(int)temp1.utility,temp1.alpha,temp1.beta,ot);
					    	 else
					    	 
					    		 PrintAlphaBetaLog(temp1,temp1.currentIndex,Player,alpha,beta,ot);
					     
					     
					}
			returnCopy = temp1;		}
					else {
						if (clboard1.pits[i].getStones() == 0) {
					
						 returnCopy = temp1.copy();
						continue;
					}
					clboard1.movePlayer2(i);
					clboard1.utility = maxUtility;
					if(!sameLayer){
					clboard1.currentDepth++;
					}
					
					if(clboard1.currentDepth == cutOffDepth  ){
						if (isMancalaPlayer1(clboard1, i))
							PrintAlphaBetaLog(clboard1,i,Player,alpha,beta,ot);
						}
						else{
							PrintAlphaBetaLog(clboard1,i,Player,alpha,beta,ot);
						}
						
						
				          Board bts =clboard1.BoardPlayer1().alphaMax(opponent,false,i,false,"min",next,alpha,beta,ot);
				          
				//	 PrintPits(clboard1);
					 /* if(clboard1.utility >temp.utility){
						  clboard1.utility = temBackup;
					  }*/
					 if(temp1.utility >= bts.utility){
				    	 temp1.utility =bts.utility;
				     }
				     else{
				    	 temp1.utility = temp1.utility;
				     }
					 if(bts.utility <= temp1.alpha){
						
						 if((callFunction =="min"))
							 
				    		 PrintAlphaBetaLog(temp1,temp1.currentIndex,Player,alpha,beta,ot);
						  else
					    		 PrintAlphaBetaLog(temp1,temp1.currentIndex,opponent,alpha,beta,ot);
						 return temp1;
						}	
					
						
						
						beta = Math.min(temp1.beta, bts.utility);
						temp1.beta = beta;
				     if(!sameLayer){
				    	 if(temp1.currentDepth == 0)
				    		 clboard1.Printroot("root"+","+"0"+","+(int)temp1.utility,temp1.alpha,temp1.beta,ot);
				    	 else
				    		 PrintAlphaBetaLog(temp1,temp1.currentIndex,opponent,alpha,beta,ot);
				     }
				     else{
				    	 if(temp1.currentDepth == 0)
				    		 clboard1.Printroot("root"+","+"0"+","+(int)temp1.utility,temp1.alpha,temp1.beta,ot);
				    	 else
				    	 
				    		 PrintAlphaBetaLog(temp1,temp1.currentIndex,Player,alpha,beta,ot);
				     
				     }
				 
				   returnCopy = temp1.copy();
				}
				}
	
			}
			if(Player == 1){
				int opponent = 2;
				if (IsTerminal(freemove)) {
					this.utility = (int) Eval(this,opponent);
				
					PrintAlphaBetaLog(this,pitNumber,opponent,alpha,beta,ot);
					return this;
					}
	
				
				boolean terminalFreemove = false;
				for (int i = 1; i <=boardPlayer1.length; i++) {
					int indexBackup = i;
					
					Board clboard1 = temp1.copy();
					double minUtility = Double.POSITIVE_INFINITY;
					double maxUtility = Double.NEGATIVE_INFINITY;
					if (isMancalaPlayer1(clboard1, i)) {
						clboard1.movePlayer1(i);
						//PrintPits(clboard1);
						if(!sameLayer){
							clboard1.currentDepth++;
							}
						if(isGameOverPlayer1(clboard1) || isGameOverPlayer2(clboard1)){
							clboard1.utility = minUtility;
							PrintAlphaBetaLog(clboard1,i,Player,alpha,beta,ot);
							clboard1.utility = (int) Eval(clboard1,opponent);
							PrintAlphaBetaLog(clboard1,i,Player,alpha,beta,ot);
					if(temp1.utility >= clboard1.utility){
				    	 temp1.utility =clboard1.utility;
				     }
				 	 
				 	else{
				    	 temp1.utility = temp1.utility;
				     }
					if(isGameOverPlayer1(clboard1) || isGameOverPlayer2(clboard1)){
			    		 clboard1.Printroot("root"+","+"0"+","+(int)temp1.utility,alpha,beta,ot);
					 }
			    		 else {
					if(callFunction =="min")
						PrintAlphaBetaLog(temp1,temp1.currentIndex,Player,alpha,beta,ot);
						else
							PrintAlphaBetaLog(temp1,temp1.currentIndex,opponent,alpha,beta,ot);}
					returnCopy = temp1.copy();
					return returnCopy;
					}
						else
							clboard1.utility = minUtility;
						
						PrintAlphaBetaLog(clboard1,i,Player,alpha,beta,ot);
					 	Board bt = clboard1.Alphamin(Player,true,i,true,"min",next,alpha,beta,ot);
					// 	PrintPits(clboard1);
					 	 if(temp1.utility >= bt.utility){
					    	 temp1.utility =bt.utility;
					     }
					 	 
					 	else{
					    	 temp1.utility = temp1.utility;
					     }
					 	 if(bt.utility <= temp1.alpha){
					 		
							 if((callFunction =="min"))
					    		 PrintAlphaBetaLog(temp1,temp1.currentIndex,Player,alpha,beta,ot);
							  else
						    		 PrintAlphaBetaLog(temp1,temp1.currentIndex,opponent,alpha,beta,ot);
							 return temp1;
							}
							
							beta = Math.min(temp1.beta, bt.utility);
							temp1.beta = beta;
						beta = Math.min(beta,bt.utility);
						temp1.beta = beta;
					 	if(!sameLayer){
					    	 if(temp1.currentDepth == 0)
					    		 clboard1.Printroot("root"+","+"0"+","+(int)temp1.utility,temp1.alpha,temp1.beta,ot);
					    	 else
					    		 PrintAlphaBetaLog(temp1,temp1.currentIndex,opponent,alpha,beta,ot);
					     }
					     else{
					    	 if(temp1.currentDepth == 0)
					    		 clboard1.Printroot("root"+","+"0"+","+(int)temp1.utility,temp1.alpha,temp1.beta,ot);
					    	 else
					    	 
					    		 PrintAlphaBetaLog(temp1,temp1.currentIndex,Player,alpha,beta,ot);
					     
					     
					}
			returnCopy = temp1;		}
					else {
					if (clboard1.pits[i].getStones() == 0) {
						 returnCopy = temp1.copy();
						continue;
					}
					clboard1.movePlayer1(i);
					clboard1.utility = maxUtility;
					if(!sameLayer){
					clboard1.currentDepth++;
					}
					
					if(clboard1.currentDepth == cutOffDepth  ){
						if (isMancalaPlayer1(clboard1, i))
							PrintAlphaBetaLog(clboard1,i,Player,alpha,beta,ot);
						}
						else{
							PrintAlphaBetaLog(clboard1,i,Player,alpha,beta,ot);
						}
						
						
				Board bt =	 clboard1.BoardPlayer2().alphaMax(opponent,false,i,false,"min",next,alpha,beta,ot);
				//	 PrintPits(clboard1);
					  /*if(clboard1.utility >temp2.utility){
						  clboard1.utility = temBackup;
					  }*/
					 if(temp1.utility >= bt.utility){
				    	 temp1.utility =bt.utility;
				     }
				     else{
				    	 temp1.utility = temp1.utility;
				     }
					 if(bt.utility <= temp1.alpha){
						
						 PrintAlphaBetaLog(temp1,temp1.currentIndex,opponent,alpha,beta,ot);
						 return temp1;
						}
						
						beta = Math.min(temp1.beta, bt.utility);
						temp1.beta = beta;
				     if(!sameLayer){
				    	 if(temp1.currentDepth == 0)
				    		 clboard1.Printroot("root"+","+"0"+","+(int)temp1.utility,temp1.alpha,temp1.beta,ot);
				    	 else
				    		 PrintAlphaBetaLog(temp1,temp1.currentIndex,opponent,alpha,beta,ot);
				     }
				     else{
				    	 if(temp1.currentDepth == 0)
				    		 clboard1.Printroot("root"+","+"0"+","+(int)temp1.utility,temp1.alpha,temp1.beta,ot);
				    	 else
				    	 
				    		 PrintAlphaBetaLog(temp1,temp1.currentIndex,Player,alpha,beta,ot);
				     
				     }
				    	 
				   returnCopy = temp1.copy();
				}
			}
			}
			
			return returnCopy;
			
		}
		public Board max(int Player,boolean freemove,int pitNumber,boolean sameLayer,String callFunction, Board next,PrintWriter ot) throws ClassNotFoundException, IOException {
					Board temp = copy();
			Board bt =null;
			temp.utility = Double.NEGATIVE_INFINITY;
		    Board returnCopy = null;
			temp.currentIndex =pitNumber;
			Board Backup =null;
			if (Player == 1) {
			int opponent = 2;
			
			 
			if (IsTerminal(freemove)) {
				this.utility = (int) Eval(this,Player);
				 PrintLog(this,pitNumber,opponent,ot);
				return this;
	
			}
			boolean terminalFreemove = false;
				for (int i = 1; i <=boardPlayer1.length; i++) {
					Board backsate = temp.copy();
					Board clboard = temp.copy();
					double maxUtility = Double.NEGATIVE_INFINITY;
					double minUtility = Double.POSITIVE_INFINITY;
					if (isMancalaPlayer1(clboard, i)) {
						Board back = clboard.copy();
						clboard.movePlayer1(i);
						if(!sameLayer){
							clboard.currentDepth++;
							
							}
						
						if(isGameOverPlayer1(clboard) || isGameOverPlayer2(clboard)){
							/*clboard.utility = maxUtility;
							PrintLog(clboard,i,Player);*/    //Need to check code so if you need to print the inf value at leaf node or not
							clboard.utility = maxUtility;
							PrintLog(clboard,i,Player,ot);
							clboard.utility = (int) Eval(clboard,Player);
							PrintLog(clboard,i,Player,ot);
					/*if(temp.utility <= clboard.utility){
				    	 temp.utility =clboard.utility;
				     }
				 	 
					 	else{
					    	 temp.utility = temp.utility;
					     }*/
							temp.utility = Math.max(temp.utility, clboard.utility);
						
					if(callFunction =="max")
					
					PrintLog(temp,temp.currentIndex,Player,ot);
					else
						PrintLog(temp,temp.currentIndex,opponent,ot);
					   
						returnCopy = temp.copy();
						   /*if(returnCopy.currentDepth ==1 ){
						    	 if(temp.utility > max_eval){
						    		 max_eval=temp.utility;
						    		 minObj.next =clboard.copy() ;
						    	 }
					    	 
						     }*/
				return returnCopy;
						}
							else
								clboard.utility = maxUtility;
						
						PrintLog(clboard,i,Player,ot);
					
						
						Board bts=  clboard.max(Player,true,i,true,"max",next,ot);
						/*if(temp.utility <= bts.utility){
					    	 temp.utility =bts.utility;
					     }
					 	else{
					    	 temp.utility = temp.utility;
					     }*/
						temp.utility = Math.max(temp.utility, bts.utility);
						if(!sameLayer){
					    	 if(temp.currentDepth == 0){
					    	//	 nextState.maxBoards.add(bt);
					    		 clboard.Printroot("root"+","+"0"+","+(int)temp.utility,ot);
					    	 returnCopy = temp.copy();
							 continue;
					    	 }
					    	 else
					    	  PrintLog(temp,temp.currentIndex,opponent,ot);
					     
						returnCopy =temp;
						}
					     else{
					    	 if(temp.currentDepth == 0){
					    	//	 nextState.maxBoards.add(bt);
					    		 clboard.Printroot("root"+","+"0"+","+(int)temp.utility,ot);
						    	 returnCopy = temp.copy();
								 continue;}
					    	 else
					    	 
					    	 PrintLog(temp,temp.currentIndex,Player,ot);
					     
					     }
						returnCopy = temp.copy();	} 
				
					else {
					if (clboard.pits[i].getStones() == 0) {
						 returnCopy = temp.copy();
						 continue;
					}
					clboard.utility = minUtility;
					clboard.movePlayer1(i);
				//	PrintPits(clb,oard);
					if(!sameLayer){
						clboard.currentDepth++;
						}
			
					///PrintLog(clboard,i,opponent);
					if(clboard.currentDepth == cutOffDepth  ){
					if (isMancalaPlayer1(clboard, i))
					PrintLog(clboard,i,Player,ot);
					}
					else{
						PrintLog(clboard,i,Player,ot);
					}
					
					//Board backup = clboard.copy();
					 
				    //	Board Backup = clboard.copy();
					backsate= clboard.copy();
				bt =clboard.BoardPlayer2().min(opponent,false,i,false,"max",next,ot);
					//PrintPits(clboard);
					
					  /*if(temp.utility <= bt.utility){
					    	 temp.utility =bt.utility;
					     }*/
					temp.utility = Math.max(temp.utility, bt.utility);
					/*  else if(sameLayer == true) {
						  temp.utility = bt.utility;
					  }
					  else {
						  temp.utility = temp.utility
					  }
					  */
					
					  
					     if(!sameLayer){
					    	 if(temp.currentDepth == 0){
					    	//	 nextState.maxBoards.add(bt);
					    	clboard.Printroot("root"+","+"0"+","+(int)temp.utility,ot);
					    		 
							    /*	 if(bt.utility > max_eval ){
							    		 max_eval=bt.utility;
							    		 minObj.next =bt.copy() ;
							    	 }*/
							    	 
							     
							    
					    	 returnCopy = temp.copy();
					    	 
							continue;}
					    	 else
					    	  PrintLog(temp,temp.currentIndex,opponent,ot);
					     }
					     else{
					    	 if(temp.currentDepth == 0){
					    		// nextState.maxBoards.add(bt);
					    		 clboard.Printroot("root"+","+"0"+","+(int)temp.utility,ot);
	
	//					    	/* if(bt.utility > max_eval ){
	//					    		 max_eval=bt.utility;
	//					    		 minObj.next =bt.copy() ;
	//					    	 }*/
					    		 returnCopy = temp.copy();
								 continue;
								 }
					    	 
					    	 else{
					    	 
					    	 PrintLog(temp,temp.currentIndex,Player,ot);
					    	 }
					     }
					     
					    	
					     }
					
						 returnCopy = temp;
							if( !isMancalaPlayer1(backsate,i)){
								if(temp.currentDepth ==0){
									if(bt.utility > max_eval ){
							    		 max_eval=bt.utility;
							    		 minObj.next =clboard.copy() ;
							    		
							    	 }
								}
								else {
									if(temp.currentDepth ==1){
										if(bt.utility > max_eval ){
								    		 max_eval=bt.utility;
								    		 minObj.next =clboard.copy() ;
								    		
								    	 }
									
								}
							 }
							}
				}  
					   
			}
			
			if(Player == 2){
				int opponent = 1;
				
				 
				if (IsTerminal(freemove)) {
					this.utility = (int) Eval(this,Player);
					 PrintLog(this,pitNumber,opponent,ot);
					return this;
	
				}
				boolean terminalFreemove = false;
					for (int i = 1; i <=boardPlayer1.length; i++) {
	
						Board clboard = temp.copy();
						Board backsate = clboard.copy();
						double maxUtility = Double.NEGATIVE_INFINITY;
						double minUtility = Double.POSITIVE_INFINITY;
						if (isMancalaPlayer2(clboard, i)) {
							clboard.movePlayer2(i);
							if(!sameLayer){
								clboard.currentDepth++;
								
								}
							
							if(isGameOverPlayer1(clboard) || isGameOverPlayer2(clboard)){
								/*clboard.utility = maxUtility;
								PrintLog(clboard,i,Player);*/    //Need to check code so if you need to print the inf value at leaf node or not
								clboard.utility = maxUtility;
								PrintLog(clboard,i,Player,ot);
								clboard.utility = (int) Eval(clboard,Player);
								PrintLog(clboard,i,Player,ot);
						temp.utility = Math.max(temp.utility, clboard.utility);
						
						if(callFunction =="max")
						PrintLog(temp,temp.currentIndex,Player,ot);
						else
							PrintLog(temp,temp.currentIndex,opponent,ot);
							returnCopy = temp.copy();
							 /*  if(returnCopy.currentDepth ==1 ){
							    	 if(temp.utility > max_eval){
							    		 max_eval=temp.utility;
							    		 minObj.next =clboard.copy() ;
							    	 }
						    	 
							     }*/
	
							return returnCopy;
							}
								else
									clboard.utility = maxUtility;
							
							PrintLog(clboard,i,Player,ot);
						
							
						 bt=  clboard.max(Player,true,i,true,"max",next,ot);
							temp.utility = Math.max(temp.utility, bt.utility);
							if(!sameLayer){
						    	 if(temp.currentDepth == 0){
						    		// nextState.maxBoards.add(bt);
						    		 clboard.Printroot("root"+","+"0"+","+(int)temp.utility,ot);
						    		 returnCopy = temp.copy();
									 continue;
						    		 }
						    	 else
						    	  PrintLog(temp,temp.currentIndex,opponent,ot);
						    	 returnCopy =temp;
						    	 
							}
						     else{
						    	 if(temp.currentDepth == 0){
						    		// nextState.maxBoards.add(bt);
						    		 clboard.Printroot("root"+","+"0"+","+(int)temp.utility,ot);
						    		 returnCopy = temp.copy();
									 continue;
						    	 }
						    	 else
						    	 
						    	 PrintLog(temp,temp.currentIndex,Player,ot);
						     
						     }
							returnCopy = temp.copy();
						}
						else {
						if (clboard.pits[i].getStones() == 0) {
							 returnCopy = temp.copy();
							 continue;
						}
						clboard.utility = minUtility;
						clboard.movePlayer2(i);
					//	PrintPits(clb,oard);
						if(!sameLayer){
							clboard.currentDepth++;
							}
				
						///PrintLog(clboard,i,opponent);
						if(clboard.currentDepth == cutOffDepth  ){
						if (isMancalaPlayer1(clboard, i))
						PrintLog(clboard,i,Player,ot);
						}
						else{
							PrintLog(clboard,i,Player,ot);
						}
						
						 Backup = clboard.copy();
					 bt =clboard.BoardPlayer1().min(opponent,false,i,false,"max",next,ot);
						//PrintPits(clboard);
							temp.utility = Math.max(temp.utility, bt.utility);
						
						     if(!sameLayer){
						    	 if(temp.currentDepth == 0){
						    		// nextState.maxBoards.add(bt);
						    		 clboard.Printroot("root"+","+"0"+","+(int)temp.utility,ot);
						    		 returnCopy = temp.copy();
									 continue;}
						    	 else
						    	  PrintLog(temp,temp.currentIndex,opponent,ot);
						     }
						     else{
						    	 if(temp.currentDepth == 0){
						    		// nextState.maxBoards.add(bt);
						    	 
						    		 clboard.Printroot("root"+","+"0"+","+(int)temp.utility,ot);
						    		 returnCopy = temp.copy();
									 continue;}
						    	 else
						    	 
						    	 PrintLog(temp,temp.currentIndex,Player,ot);
						     
						     }
						
						 returnCopy = temp;
						 if( !isMancalaPlayer1(backsate,i)){
								if(temp.currentDepth ==0){
									if(bt.utility > max_eval ){
							    		 max_eval=bt.utility;
							    		 minObj.next =clboard.copy() ;
							    		
							    	 }
								}
								else {
									if(temp.currentDepth ==1){
										if(bt.utility > max_eval ){
								    		 max_eval=bt.utility;
								    		 minObj.next =clboard.copy() ;
								    		
								    	 }
									
								}
							 }
							}
			
				 
				    	 }
				    	 
				     }
						}
			
				
			return returnCopy;
			
		
		}
	
		
		public Board maxnextsate(int Player,boolean freemove,int pitNumber,boolean sameLayer,String callFunction, Board next) throws ClassNotFoundException, IOException {
		
			Board temp = copy();
			
			temp.utility = Double.NEGATIVE_INFINITY;
		    Board returnCopy = null;
			temp.currentIndex =pitNumber;
			Board Backup =null;
			if (Player == 1) {
			int opponent = 2;
			
			 
			
			boolean terminalFreemove = false;
				for (int i = 1; i <=boardPlayer1.length; i++) {
					
					Board clboard = temp.copy();
					Board backsate = clboard.copy();
					Board bt=null;
					double maxUtility = Double.NEGATIVE_INFINITY;
					double minUtility = Double.POSITIVE_INFINITY;
					
					if (IsTerminal(freemove)) {
						this.utility = (int) Eval(this,Player);
						temp.utility = Math.max(temp.utility, this.utility);
						bt = this;
					}
					else {
						
					if (isMancalaPlayer1(clboard, i)) {
						Board back = clboard.copy();
						clboard.movePlayer1(i);
						if(!sameLayer){
							clboard.currentDepth++;
							
							}
						
						if(isGameOverPlayer1(clboard) || isGameOverPlayer2(clboard)){
						
							clboard.utility = maxUtility;
							
							clboard.utility = (int) Eval(clboard,Player);
							bt =clboard;
							temp.utility = Math.max(temp.utility, clboard.utility);
				
						}
							else
								clboard.utility = maxUtility;
						
						
					
						
						 bt=  clboard.maxnextsate(Player,true,i,true,"max",next);
						
						temp.utility = Math.max(temp.utility, bt.utility);
						
					}
					else {
					if (clboard.pits[i].getStones() == 0) {
						 returnCopy = temp.copy();
						 continue;
					}
					clboard.utility = minUtility;
					clboard.movePlayer1(i);
					if(!sameLayer){
						clboard.currentDepth++;
						}
			
				
				
					
			bt =clboard.BoardPlayer2().minnextstate(opponent,false,i,false,"max",next);
					
					temp.utility = Math.max(temp.utility, bt.utility);
						
					     }
					}
						 returnCopy = temp;
						/* if(cutOffDepth%2 == 0){*/
						 /*if(temp.currentDepth ==0 && !isMancalaPlayer1(backsate,i) ){
					    	 if(bt.utility > max_eval ){
					    		 max_eval=bt.utility;
					    		 minObj.next =clboard.copy() ;
					    		
					    	 }
					    	 */
					
					if( !isMancalaPlayer1(backsate,i)){
						if(temp.currentDepth ==0){
							if(bt.utility > max_eval ){
					    		 max_eval=bt.utility;
					    		 minObj.next =clboard.copy() ;
					    		
					    	 }
						}
						else {
							if(temp.currentDepth ==1){
								if(bt.utility > max_eval ){
						    		 max_eval=bt.utility;
						    		 minObj.next =clboard.copy() ;
						    		
						    	 }
							
						}
					 }
					}
						//
						/*  if(backsate.currentDepth ==1 && !isMancalaPlayer1(temp,i) ){
				    	 if(temp.utility > max_eval ){
				    		 max_eval=temp.utility;
				    		 minObj.next =clboard.copy() ;
				    		
				    	 }
				    	 
				     }*/
	
				
			}
			}if (Player == 2) {
				int opponent = 1;
				
				 
				
				boolean terminalFreemove = false;
					for (int i = 1; i <=boardPlayer1.length; i++) {
						
						Board clboard = temp.copy();
						Board backsate = clboard.copy();
						Board bt =null;
						double maxUtility = Double.NEGATIVE_INFINITY;
						double minUtility = Double.POSITIVE_INFINITY;
						
						if (IsTerminal(freemove)) {
							this.utility = (int) Eval(this,Player);
							temp.utility = Math.max(temp.utility, this.utility);
							bt =this;
	
						}
						else {
							
						if (isMancalaPlayer2(clboard, i)) {
							Board back = clboard.copy();
							clboard.movePlayer2(i);
							if(!sameLayer){
								clboard.currentDepth++;
								
								}
							
							if(isGameOverPlayer1(clboard) || isGameOverPlayer2(clboard)){
							
								clboard.utility = maxUtility;
								
								clboard.utility = (int) Eval(clboard,Player);
								bt =clboard;
								temp.utility = Math.max(temp.utility, clboard.utility);
					
							}
								else
									clboard.utility = maxUtility;
							
							
						
							
						 bt=  clboard.maxnextsate(Player,true,i,true,"max",next);
							
							temp.utility = Math.max(temp.utility, bt.utility);
							
						}
						else {
						if (clboard.pits[i].getStones() == 0) {
							 returnCopy = temp.copy();
							 continue;
						}
						clboard.utility = minUtility;
						clboard.movePlayer2(i);
						if(!sameLayer){
							clboard.currentDepth++;
							}
				
					
					
						
				bt =clboard.BoardPlayer1().minnextstate(opponent,false,i,false,"max",next);
						
						temp.utility = Math.max(temp.utility, bt.utility);
							
						     }
						}
						//	 returnCopy = temp;
							/* if(cutOffDepth%2 == 0){*/
							 /*if(temp.currentDepth ==0 && !isMancalaPlayer1(backsate,i) ){
						    	 if(bt.utility > max_eval ){
						    		 max_eval=bt.utility;
						    		 minObj.next =clboard.copy() ;
						    		
						    	 }
						    	 */
						
					
						if( !isMancalaPlayer1(backsate,i)){
							if(temp.currentDepth ==0){
								if(bt.utility > max_eval ){
						    		 max_eval=bt.utility;
						    		 minObj.next =clboard.copy() ;
						    		
						    	 }
							}
							else {
								if(temp.currentDepth ==1){
									if(bt.utility > max_eval ){
							    		 max_eval=bt.utility;
							    		 minObj.next =clboard.copy() ;
							    		
							    	 }
								
							}
						 }
						}
							//
							/*  if(backsate.currentDepth ==1 && !isMancalaPlayer1(temp,i) ){
					    	 if(temp.utility > max_eval ){
					    		 max_eval=temp.utility;
					    		 minObj.next =clboard.copy() ;
					    		
					    	 }
					    	 
					     }*/
							
					
				}
				}
			 return temp;
		}
		public Board minnextstate(int Player,boolean freemove,int pitNumber,boolean sameLayer,String callFunction,Board next) throws ClassNotFoundException, IOException {
	Board temp1 = copy();
			temp1.utility = Double.POSITIVE_INFINITY;
			 Board returnCopy = null;
			temp1.currentIndex =pitNumber;
			
			if (Player == 2) {
				int opponent = 1;
				
	
				
				boolean terminalFreemove = false;
				for (int i = 1; i <=boardPlayer1.length; i++) {
					int indexBackup = i;
				
					Board clboard1 = temp1.copy();
					double minUtility = Double.POSITIVE_INFINITY;
					double maxUtility = Double.NEGATIVE_INFINITY;
					if (IsTerminal(freemove)) {
						this.utility = (int) Eval(this,opponent);
						temp1.utility = Math.min(temp1.utility, this.utility);
							}
					else {
					if (isMancalaPlayer2(clboard1, i)) {
						clboard1.movePlayer2(i);
						
						if(!sameLayer){
							clboard1.currentDepth++;
							}
						if(isGameOverPlayer1(clboard1) || isGameOverPlayer2(clboard1)){
							clboard1.utility = minUtility;
							
							clboard1.utility = (int) Eval(clboard1,opponent);
							temp1.utility = Math.min(temp1.utility, clboard1.utility);
						
				     }
					else
							clboard1.utility = minUtility;
						
					
					 	Board bt = clboard1.minnextstate(Player,true,i,true,"min",next);
					
					    temp1.utility = Math.min(temp1.utility, bt.utility);
					 	
					}
					else {
					if  	(clboard1.pits[i].getStones() == 0) {
						 returnCopy = temp1.copy();
						continue;
					}
					clboard1.utility = maxUtility;
					clboard1.movePlayer2(i);
					
					if(!sameLayer){
					clboard1.currentDepth++;
					}
					
					
						
				          Board bts =clboard1.BoardPlayer1().maxnextsate(opponent,false,i,false,"min",next);
				          
		
				          temp1.utility = Math.min(temp1.utility, bts.utility);
				     
				     
					}	
					}
				   returnCopy = temp1;
				  
				
		
			}
			
				
			}
			if (Player == 1) {
				int opponent = 2;
				
	
				
				boolean terminalFreemove = false;
				for (int i = 1; i <=boardPlayer1.length; i++) {
					int indexBackup = i;
				
					Board clboard1 = temp1.copy();
					double minUtility = Double.POSITIVE_INFINITY;
					double maxUtility = Double.NEGATIVE_INFINITY;
					if (IsTerminal(freemove)) {
						this.utility = (int) Eval(this,opponent);
						temp1.utility = Math.min(temp1.utility, this.utility);
							}
					else {
					if (isMancalaPlayer1(clboard1, i)) {
						clboard1.movePlayer1(i);
						
						if(!sameLayer){
							clboard1.currentDepth++;
							}
						if(isGameOverPlayer1(clboard1) || isGameOverPlayer2(clboard1)){
							clboard1.utility = minUtility;
							
							clboard1.utility = (int) Eval(clboard1,opponent);
							temp1.utility = Math.min(temp1.utility, clboard1.utility);
						
				     }
					else
							clboard1.utility = minUtility;
						
					
					 	Board bt = clboard1.minnextstate(Player,true,i,true,"min",next);
					
					    temp1.utility = Math.min(temp1.utility, bt.utility);
					 	
					}
					else {
					if  	(clboard1.pits[i].getStones() == 0) {
						 returnCopy = temp1.copy();
						continue;
					}
					clboard1.utility = maxUtility;
					clboard1.movePlayer1(i);
					
					if(!sameLayer){
					clboard1.currentDepth++;
					}
					
					
						
				          Board bts =clboard1.BoardPlayer2().maxnextsate(opponent,false,i,false,"min",next);
				          
		
				          temp1.utility = Math.min(temp1.utility, bts.utility);
				     
				     
					}	
					}
				   returnCopy = temp1;
				  
				
		
			}
			
				
			}
			 return temp1;
		}
	
		public Board min(int Player,boolean freemove,int pitNumber,boolean sameLayer,String callFunction,Board next,PrintWriter ot) throws ClassNotFoundException, IOException {
			Board temp1 = copy();
			temp1.utility = Double.POSITIVE_INFINITY;
			 Board returnCopy = null;
			temp1.currentIndex =pitNumber;
			
			if (Player == 2) {
				int opponent = 1;
				if (IsTerminal(freemove)) {
					this.utility = (int) Eval(this,opponent);
				
					 PrintLog(this,pitNumber,opponent,ot);
					return this;
					}
	
				
				boolean terminalFreemove = false;
				for (int i = 1; i <=boardPlayer1.length; i++) {
					int indexBackup = i;
					
					Board clboard1 = temp1.copy();
					double minUtility = Double.POSITIVE_INFINITY;
					double maxUtility = Double.NEGATIVE_INFINITY;
					if (isMancalaPlayer2(clboard1, i)) {
						clboard1.movePlayer2(i);
						//PrintPits(clboard1);
						if(!sameLayer){
							clboard1.currentDepth++;
							}
						if(isGameOverPlayer1(clboard1) || isGameOverPlayer2(clboard1)){
							clboard1.utility = minUtility;
							PrintLog(clboard1,i,Player,ot);
							clboard1.utility = (int) Eval(clboard1,opponent);
							PrintLog(clboard1,i,Player,ot);
				/*	if(temp1.utility >= clboard1.utility){
				    	 temp1.utility =clboard1.utility;
				     }
				 	 
				 	else{
				    	 temp1.utility = temp1.utility;
				     }*/temp1.utility = Math.min(temp1.utility, clboard1.utility);
				   
				     if(callFunction =="min")
						PrintLog(temp1,temp1.currentIndex,Player,ot);
						else
							PrintLog(temp1,temp1.currentIndex,opponent,ot);
					returnCopy = temp1.copy();
					return returnCopy;
					}
						else
							clboard1.utility = minUtility;
						
						PrintLog(clboard1,i,Player,ot);
					 	Board bt = clboard1.min(Player,true,i,true,"min",next,ot);
					// 	PrintPits(clboard1);
					 	/* if(temp1.utility >= bt.utility){
					    	 temp1.utility =bt.utility;
					     }
					 	 
					 	else{
					    	 temp1.utility = temp1.utility;
					     }*/temp1.utility = Math.min(temp1.utility, bt.utility);
					 	if(!sameLayer){
					    	 if(temp1.currentDepth == 0){
					    		 clboard1.Printroot("root"+","+"0"+","+(int)temp1.utility,ot);
					    		 returnCopy = temp1.copy();		
								 continue;}
					    	 else
					    	  PrintLog(temp1,temp1.currentIndex,opponent,ot);
					     }
					     else{
					    	 if(temp1.currentDepth == 0){
					    		 clboard1.Printroot("root"+","+"0"+","+(int)temp1.utility,ot);
					    		 returnCopy = temp1.copy();		
								 continue;}
					    	 else
					    	 
					    	 PrintLog(temp1,temp1.currentIndex,Player,ot);
					     
					     
					}
					
					 	returnCopy =temp1;}
					else {
					if  	(clboard1.pits[i].getStones() == 0) {
						 returnCopy = temp1.copy();
						continue;
					}
					clboard1.movePlayer2(i);
					clboard1.utility = maxUtility;
					if(!sameLayer){
					clboard1.currentDepth++;
					}
					
					if(clboard1.currentDepth == cutOffDepth  ){
						if (isMancalaPlayer1(clboard1, i))
						PrintLog(clboard1,i,Player,ot);
						}
						else{
							PrintLog(clboard1,i,Player,ot);
						}
						
						
				          Board bts =clboard1.BoardPlayer1().max(opponent,false,i,false,"min",next,ot);
				          
				//	 PrintPits(clboard1);
					  /*if(clboard1.utility >temp2.utility){
						  clboard1.utility = temBackup;
					  }*/
	 				/* if(temp1.utility >= bts.utility){
				    	 temp1.utility =bts.utility;
				     }
				     else{
				    	 temp1.utility = temp1.utility;
				     }*/
				          temp1.utility = Math.min(temp1.utility, bts.utility);
				     if(!sameLayer){
				    	 if(temp1.currentDepth == 0){
				    		 clboard1.Printroot("root"+","+"0"+","+(int)temp1.utility,ot);
				    		 returnCopy = temp1.copy();		
							 continue;}
				    	 else
				    	  PrintLog(temp1,temp1.currentIndex,opponent,ot);
				     }
				     else{
				    	 if(temp1.currentDepth == 0){
				    		 clboard1.Printroot("root"+","+"0"+","+(int)temp1.utility,ot);
				    		 returnCopy = temp1.copy();		
							 continue;}
				    	 else
				    	 
				    	 PrintLog(temp1,temp1.currentIndex,Player,ot);
				     
				    }
					}
				   returnCopy = temp1.copy();
				/*   if(temp1.pits[7].getStones() == 1 && temp1.pits[6].getStones() ==0 && temp1.pits[5].getStones() ==4 && temp1.pits[4].getStones() ==4  && temp1.pits[3].getStones() ==4 ){
					   System.out.println("Vipin");
					   
				   }*/
				  
				     
				}
	
			}
			if(Player == 1){
				int opponent = 2;
				if (IsTerminal(freemove)) {
					this.utility = (int) Eval(this,opponent);
				
					 PrintLog(this,pitNumber,opponent,ot);
					return this;
					}
	
				
				boolean terminalFreemove = false;
				for (int i = 1; i <=boardPlayer1.length; i++) {
					int indexBackup = i;
					
					Board clboard1 = temp1.copy();
					double minUtility = Double.POSITIVE_INFINITY;
					double maxUtility = Double.NEGATIVE_INFINITY;
					if (isMancalaPlayer1(clboard1, i)) {
						clboard1.movePlayer1(i);
						//PrintPits(clboard1);
						if(!sameLayer){
							clboard1.currentDepth++;
							}
						if(isGameOverPlayer1(clboard1) || isGameOverPlayer2(clboard1)){
							clboard1.utility = minUtility;
							PrintLog(clboard1,i,Player,ot);
							clboard1.utility = (int) Eval(clboard1,opponent);
							PrintLog(clboard1,i,Player,ot);
					temp1.utility = Math.min(temp1.utility, clboard1.utility);
					
					if(callFunction =="min")
						PrintLog(temp1,temp1.currentIndex,Player,ot);
						else
							PrintLog(temp1,temp1.currentIndex,opponent,ot);
					returnCopy = temp1.copy();
					return returnCopy;
					}
						else
							clboard1.utility = minUtility;
						
						PrintLog(clboard1,i,Player,ot);
					 	Board bt = clboard1.min(Player,true,i,true,"min",next,ot);
					// 	PrintPits(clboard1);
					 	temp1.utility = Math.min(temp1.utility, bt.utility);
					 	if(!sameLayer){
					    	 if(temp1.currentDepth == 0){
					    		 clboard1.Printroot("root"+","+"0"+","+(int)temp1.utility,ot);
					    	 returnCopy = temp1.copy();		
							 continue;}
					    	 else
					    	  PrintLog(temp1,temp1.currentIndex,opponent,ot);
					     }
					     else{
					    	 if(temp1.currentDepth == 0){
					    		 clboard1.Printroot("root"+","+"0"+","+(int)temp1.utility,ot);
					    	 returnCopy = temp1.copy();		
							 continue;}
					    	 else
					    	 
					    	 PrintLog(temp1,temp1.currentIndex,Player,ot);
					     
					     
					}
					 	returnCopy =temp1;}
					else {
					if (clboard1.pits[i].getStones() == 0) {
						 returnCopy = temp1.copy();
						continue;
					}
					clboard1.movePlayer1(i);
					clboard1.utility = maxUtility;
					if(!sameLayer){
					clboard1.currentDepth++;
					}
					
					if(clboard1.currentDepth == cutOffDepth  ){
						if (isMancalaPlayer1(clboard1, i))
						PrintLog(clboard1,i,Player,ot);
						}
						else{
							PrintLog(clboard1,i,Player,ot);
						}
						
						
				Board bt =	 clboard1.BoardPlayer2().max(opponent,false,i,false,"min",next,ot);
				//	 PrintPits(clboard1);
					  temp1.utility = Math.min(temp1.utility, bt.utility);
				     if(!sameLayer){
				    	 if(temp1.currentDepth == 0){
				    		 clboard1.Printroot("root"+","+"0"+","+(int)temp1.utility,ot);
				    		 returnCopy = temp1.copy();		
							 continue;}
				    	 else
				    	  PrintLog(temp1,temp1.currentIndex,opponent,ot);
				     }
				     else{
				    	 if(temp1.currentDepth == 0){
				    		 clboard1.Printroot("root"+","+"0"+","+(int)temp1.utility,ot);
				    		 returnCopy = temp1.copy();		
							 continue;}
				    	 else
				    	 
				    	 PrintLog(temp1,temp1.currentIndex,Player,ot);
				     
				     }
					}
				    	 
				   returnCopy = temp1.copy();
				}
			}
			
	
			return returnCopy;
			
		}
		/*public void PrintPits(Board bd) {
			for (int i = 0; i < pits.length; i++) {
				System.out.println(bd.pits[i].getStones());
			}
		}*/
		@SuppressWarnings("static-access")
		public void PrintLog(Board bd,int pitNumber, int Player,PrintWriter ot) throws IOException {
			
			if(minObj.plyer ==1){
			if(Player == 1){
			   if((bd.utility == Double.POSITIVE_INFINITY) ||(bd.utility == Double.NEGATIVE_INFINITY)){
				ot.println("B"+(pitNumber+1)+","+bd.currentDepth+","+bd.utility);
				
			   }
			   else{
				   ot.println("B"+(pitNumber+1)+","+bd.currentDepth+","+(int)bd.utility);
				  
					
			   }
			
			}
			else {
				 if((bd.utility == Double.POSITIVE_INFINITY) ||(bd.utility == Double.NEGATIVE_INFINITY)){
					 ot.println("A"+(pitNumber+1)+","+bd.currentDepth+","+bd.utility);
					 
					
				   }
				   else{
					   ot.println("A"+(pitNumber+1)+","+bd.currentDepth+","+(int)bd.utility);
					   
					  
				   }
				
			
			}
			}
			else if(minObj.plyer ==2){
				if(Player == 2){
					
					   if((bd.utility == Double.POSITIVE_INFINITY) ||(bd.utility == Double.NEGATIVE_INFINITY)){
							 ot.println("A"+(pitNumber+1)+","+bd.currentDepth+","+bd.utility);
							 
							
						   }
						   else{
							   ot.println("A"+(pitNumber+1)+","+bd.currentDepth+","+(int)bd.utility);
							   
							  
						   }
					
					}
					else {
						   if((bd.utility == Double.POSITIVE_INFINITY) ||(bd.utility == Double.NEGATIVE_INFINITY)){
								ot.println("B"+(pitNumber+1)+","+bd.currentDepth+","+bd.utility);
								
							   }
							   else{
								   ot.println("B"+(pitNumber+1)+","+bd.currentDepth+","+(int)bd.utility);
								  
									
							   }
					}
						
			}
			
			
		}
		@SuppressWarnings("static-access")
		public void Printroot(String input,PrintWriter ot) throws IOException{
		
			ot.println(input);
			
		}
		
		public void Printroot(String input,double input1, double input2,PrintWriter ot) throws IOException{
			String Alpha;
			String Beta;
			
			
			if(Double.isInfinite(input1)){
				Alpha = String.valueOf(input1);
				
			}
			else {
				Alpha = String.valueOf((int)input1);
			}
			if(Double.isInfinite(input2)){
				Beta = String.valueOf(input2);
				
			}
			else {
				Beta = String.valueOf((int)input2);
			}
			ot.println(input+","+Alpha+","+Beta);
			//System.out.println(input+","+Alpha+","+Beta);
			
		}
		/*public void Printroot(String input,PrintWriter ot) throws IOException{
			System.out.println(input);
				
			}
		public void PrintLog(Board bd,int pitNumber, int Player,PrintWriter ot) throws IOException {
		
		PrintWriter out = new PrintWriter(new FileWriter("C:\\Users\\vipin\\Documents\\EclipseProject\\mancala\\Traverse_Vip.txt",true));
		
	
	
		if(Player == 1){
		   if((bd.utility == Double.POSITIVE_INFINITY) ||(bd.utility == Double.NEGATIVE_INFINITY)){
				System.out.println(("B"+(pitNumber+1)+","+bd.currentDepth+","+bd.utility));
				
		   }
		   else{
			   System.out.println("B"+(pitNumber+1)+","+bd.currentDepth+","+(int)bd.utility);
				
		   }
		
		}
		else {
			 if((bd.utility == Double.POSITIVE_INFINITY) ||(bd.utility == Double.NEGATIVE_INFINITY)){
				 System.out.println("A"+(pitNumber+1)+","+bd.currentDepth+","+bd.utility);
				
			   }
			   else{
				   System.out.println("A"+(pitNumber+1)+","+bd.currentDepth+","+(int)bd.utility);
				  
			   }
			
		}
		}
		*/
		public void PrintAlphaBetaLog(Board bd,int pitNumber, int Player,double alpha, double beta,PrintWriter ot) throws IOException {
			
	
				String Alpha;
				String Beta;
				String Util;
				if(Double.isInfinite(bd.utility)){
					Util = String.valueOf(bd.utility);
					
				}
				else {
					Util = String.valueOf((int)bd.utility);
				}
				if(Double.isInfinite(alpha)){
					Alpha = String.valueOf(alpha);
					
				}
				else {
					Alpha = String.valueOf((int)alpha);
				}
				
				if(Double.isInfinite(beta)){
					Beta = String.valueOf(beta);
					
				}
				else {
					Beta = String.valueOf((int)beta);
				}
				
			if(Player == 1){
			 
				ot.println("B"+(pitNumber+1)+","+bd.currentDepth+","+Util+","+Alpha+","+Beta);
				  //System.out.println("B"+(pitNumber+1)+","+bd.currentDepth+","+Util+","+Alpha+","+Beta);
	
			   }
			
			
			else {
		
			 ot.println("A"+(pitNumber+1)+","+bd.currentDepth+","+Util+","+Alpha+","+Beta);
				// System.out.println("A"+(pitNumber+1)+","+bd.currentDepth+","+Util+","+Alpha+","+Beta);
	
				   }
				
			}
			
	
		public Board BoardPlayer2() throws ClassNotFoundException, IOException {
			Board bd = copy();
			int[] temp1 = new int[boardPlayer1.length];
			int[] temp2 = new int[boardPlayer1.length];
			for (int i = 1; i <= boardPlayer1.length; i++) {
				temp1[i - 1] = (int) bd.pits[i].getStones();
			}
			for (int k = boardPlayer2.length + 2; k < boardSize; k++) {
				temp2[k - (boardPlayer2.length + 2)] = (int) bd.pits[k].getStones();
	
			}
			for (int i = 1; i <= boardPlayer1.length; i++) {
				bd.pits[i].setStones(temp2[temp2.length - i]);
			}
			for (int k = 1; k <= boardPlayer1.length; k++) {
				bd.pits[k + boardPlayer1.length + 1].setStones(temp1[boardPlayer1.length - k]);
	
			}
	
			return bd;
		}
	
		public boolean IsTerminal(boolean freemove) {
		     if(isGameOverPlayer1(this))
		    	 return true;
		     if(isGameOverPlayer2(this))
		    	 return true;
		     if(this.currentDepth == cutOffDepth){
		    	 if(freemove){
		    		 return false;
		    	 }
		    	 else
		    		 return true;
		    	 
		     }
			return false;
			
		}
		public boolean IsTerminal(Board bd,boolean freemove) {
		     if(isGameOverPlayer1(bd))
		    	 return true;
		     if(isGameOverPlayer2(bd))
		    	 return true;
		     if(bd.currentDepth == cutOffDepth){
		    	 if(freemove){
		    		 return false;
		    	 }
		    	 else
		    		 return true;
		    	 
		     }
			return false;
			
		}
		
		
		public Board BoardPlayer1() throws ClassNotFoundException, IOException {
			Board bd = copy();
			int[] temp1 = new int[boardPlayer1.length];
			int[] temp2 = new int[boardPlayer1.length];
			for (int i = 1; i <= boardPlayer1.length; i++) {
				temp1[i - 1] = (int) this.pits[i].getStones();
			}
			for (int k = boardPlayer2.length + 2; k < boardSize; k++) {
				temp2[k - (boardPlayer2.length + 2)] = (int) this.pits[k].getStones();
	
			}
			for (int i = 1; i <= boardPlayer1.length; i++) {
				this.pits[i].setStones(temp2[temp2.length - i]);
			}
			for (int k = 1; k <= boardPlayer1.length; k++) {
				this.pits[k + boardPlayer1.length + 1].setStones(temp1[boardPlayer1.length - k]);
	
			}
	
			return this;
		}
	
		public  void Print(Board bd) throws IOException, ClassNotFoundException {
				
			BufferedWriter bw = new BufferedWriter(
					new FileWriter("next_state.txt"));
					//new FileWriter("C:\\Users\\vipin\\Documents\\EclipseProject\\mancala\\next_state.txt"));
			if (bd.Player == 1) {
				
				pits[] pitValue = bd.pits;
				String value = "";
				for (int k = pitValue.length - 1; k >= bd.boardPlayer2.length + 2; k--) {
					value = value + (int) bd.pits[k].getStones() + " ";
				}
				bw.write(value);
				bw.newLine();
				value = "";
				for (int i = 1; i <= bd.boardPlayer1.length; i++) {
					value = value + (int) bd.pits[i].getStones() + " ";
				}
				bw.write(value);
				bw.newLine();
				value = "";
				String value1 = String.valueOf((int) bd.pits[bd.MancalaCurrentPlayer(2, bd.boardSize)].getStones());
				bw.write(value1);
				bw.newLine();
				value1 = String.valueOf((int) bd.pits[bd.MancalaCurrentPlayer(1, bd.boardSize)].getStones());
				bw.write(value1);
				bw.newLine();
				bw.close();
			}
			if (bd.Player == 2) {
				bd = bd.BoardPlayer2();
				pits[] pitValue = bd.pits;
				String value = "";
				for (int i = 1; i <= bd.boardPlayer1.length; i++) {
					value = value + (int) bd.pits[i].getStones() + " ";
				}
				bw.write(value);
				bw.newLine();
				value = "";
				
				
				for (int k = pitValue.length - 1; k >= bd.boardPlayer2.length + 2; k--) {
					value = value + (int) bd.pits[k].getStones() + " ";
				}
				bw.write(value);
				bw.newLine();
				value = "";
				
				String value1 = String.valueOf((int) bd.pits[bd.MancalaCurrentPlayer(2, bd.boardSize)].getStones());
				bw.write(value1);
				bw.newLine();
				value1 = String.valueOf((int) bd.pits[bd.MancalaCurrentPlayer(1, bd.boardSize)].getStones());
				bw.write(value1);
				bw.newLine();
				bw.close();
			}
	
			else if (bd.Player == 2) {
				pits[] pitValue = bd.pits;
				String value = "";
				for (int i = 1; i <= bd.boardPlayer1.length; i++) {
					value = value + (int) bd.pits[i].getStones() + " ";
				}
	
				bw.write(value);
				bw.newLine();
				value = "";
				for (int k = pitValue.length - 1; k >= bd.boardPlayer2.length + 2; k--) {
					value = value + (int) bd.pits[k].getStones() + " ";
				}
				bw.write(value);
				bw.newLine();
				value = "";
				String value1 = String.valueOf((int) bd.pits[bd.MancalaCurrentPlayer(2, bd.boardSize)].getStones());
				bw.write(value1);
				bw.newLine();
				value1 = String.valueOf((int) bd.pits[bd.MancalaCurrentPlayer(1, bd.boardSize)].getStones());
				bw.write(value1);
				bw.newLine();
				bw.close();
			}
	
		}
	
	public  void GreedyPrint(Board bd) throws IOException, ClassNotFoundException {
		
		BufferedWriter bw = new BufferedWriter(
				new FileWriter("next_state.txt"));
				//new FileWriter("C:\\Users\\vipin\\Documents\\EclipseProject\\mancala\\next_state.txt"));
		if (bd.Player == 1) {
			
			pits[] pitValue = bd.pits;
			String value = "";
			for (int k = pitValue.length - 1; k >= bd.boardPlayer2.length + 2; k--) {
				value = value + (int) bd.pits[k].getStones() + " ";
			}
			bw.write(value);
			bw.newLine();
			value = "";
			for (int i = 1; i <= bd.boardPlayer1.length; i++) {
				value = value + (int) bd.pits[i].getStones() + " ";
			}
			bw.write(value);
			bw.newLine();
			value = "";
			String value1 = String.valueOf((int) bd.pits[bd.MancalaCurrentPlayer(2, bd.boardSize)].getStones());
			bw.write(value1);
			bw.newLine();
			value1 = String.valueOf((int) bd.pits[bd.MancalaCurrentPlayer(1, bd.boardSize)].getStones());
			bw.write(value1);
			bw.newLine();
			bw.close();
		}
		if (Player == 2) {
			
			pits[] pitValue = bd.pits;
			String value = "";
			for (int i = 1; i <= bd.boardPlayer1.length; i++) {
				value = value + (int) bd.pits[i].getStones() + " ";
			}
			bw.write(value);
			bw.newLine();
			value = "";
			
			
			for (int k = pitValue.length - 1; k >= bd.boardPlayer2.length + 2; k--) {
				value = value + (int) bd.pits[k].getStones() + " ";
			}
			bw.write(value);
			bw.newLine();
			value = "";
			
			String value1 = String.valueOf((int) bd.pits[bd.MancalaCurrentPlayer(2, bd.boardSize)].getStones());
			bw.write(value1);
			bw.newLine();
			value1 = String.valueOf((int) bd.pits[bd.MancalaCurrentPlayer(1, bd.boardSize)].getStones());
			bw.write(value1);
			bw.newLine();
			bw.close();
		}
	
	}
	
	}
	class pits implements Serializable {
		double stones;
		int evalValue;
	
		pits() {
			super();
		}
		public int getEvalValue() {
			return evalValue;
		}
	
		public void setEvalValue(int evalValue) {
			this.evalValue = evalValue;
		}
	
		public double getStones() {
			return stones;
		}
	
		public void setStones(double stones) {
			this.stones = stones;
		}
	
	
	
	}
	
